/* jshint -W008 */

(function(game) {
  'use strict';

  function Human() {
    if (!Human.voxel3DModel) console.die('[Human] Missing voxel3DModel (generated by Loader)');

    var human = new THREE.Mesh(Human.geometry.human, Human.material.human);

    human.key = 'human';
    human.gKey = 'humans';
    human.state = 'idle';
    human.alive = true;
    human.hp = Human.HP;
    human.hpMax = Human.HP;

    // Add generated 3D model by Loader
    human.main = Human.voxel3DModel[THREE.Math.randInt(0, Human.voxel3DModel.length - 1)].clone();

    // For moving
    human.movable = true;
    human.velocity = new THREE.Vector3();
    human._velocity = new THREE.Vector3(); // 4slomo

    // Aim line
    human.aimLine = new THREE.Line(Human.geometry.aimLine, Human.material.aimLine);
    human.aimLine.position.y = Human.AIMLINE_OFFSET_Y;
    human.add(human.aimLine);

    // Staring
    human.staringAt = null;
    human._staringAt = new THREE.Object3D();

    human.castShadow = true;

    // Add created body parts
    human.add(human.main);

    // Sight of view
    // human.sight = new THREE.Mesh(Human.geometry.sight);
    // human.sight.position.y = 1;
    // human.add(human.sight);

    // Animation helpers
    human._animationMoveTime = 0;
    human._animationMoveLean = 1; // 1/-1 = left/right

    // Collider info storage
    human.collide = new game.Collider(human, Human.COLLISION_RANGE, null, ['walls', 'furnitures']);

    // Bind
    for (var p in Human.prototype) human[p] = Human.prototype[p];

    return human;
  }

  Human.prototype.spawn = function(x, z, y) {
    console.debug('[Human] spawn ' + this.key);

    if (!game.Scene.current) console.die('[Human] Need level to spawn');

    this.position.x = x || this.position.x;
    this.position.y = y || 0;
    this.position.z = z || this.position.z;

    game.Scene.current.add(this);
    game.Scene.current.level.add(this);

    return this;
  };

  Human.prototype.stareAt = function(obj) {
    if (!obj || !obj.position) console.die('[Human] Need object with .position to stare at');

    this.staringAt = obj;

    return this;
  };

  Human.prototype.follow = function(obj) {
    if (!obj || !obj.position) console.die('[Human] Need object with .position to stare at');

    this.following = obj;
    this.es.changeDestination(this.following.position);

    return this;
  };

  Human.prototype.pickup = function(item) {
    if (!item) console.die('[Human] Need item to pickup');
    console.debug('[Human] Pickup item: ' + item.key);

    if (item.isWeapon) {
      // Drop if have one already
      if (this.weapon) this.drop();

      // Add
      this.add(item);

      // Change owner
      item.owner = this;

      // Position
      item.position.set(this.geometry.parameters.width * -.5 - item.geometry.parameters.depth, item.geometry.parameters.height * .5, 8);

      // Clone position for animation
      item._position = item.position.clone();

      this.weapon = item;

      // Adjust aimLine
      this.aimLine.position.x = this.weapon.position.x;
      this.aimLine.position.y = this.weapon.position.y;
    }

    return this;
  }

  Human.prototype.drop = function() { window.w = this.weapon;
    if (!this.weapon) return;

    this.weapon.onDrop();

    return this;
  };

  Human.prototype.shoot = function() {
    console.debug('[Human] shoot');
    if (this.weapon && this.alive) this.weapon.fire();
  };

  Human.prototype.damage = function(dmg) {
    if (!dmg) return;
    if (typeof dmg === 'number') dmg = {dmg: dmg};
    console.debug('[Human] Damage ' + this.key + ' with ' + dmg.dmg + 'dmg');

    // Blood
    this.bleed(dmg.position, dmg.rotation);

    // Blowback
    if (dmg.blowback) {
      this.velocity.x = 0;
      this.velocity.z = 0;
      this.velocity.add(this.position.clone().sub(dmg.blowback));
    }

    this.hp -= dmg.dmg;

    if (this.hp <= 0) this.die();
  };

  Human.prototype.bleed = function(pos, rot) {
    if (!pos || !rot) console.die('[Human] Need position & rotation to bleed');

    var rot2 = rot.clone();
    rot2.y = rot.y + Math.PI;

    for (var i = 0; i < 6; i++) new game.Blood(pos, rot);
    for (var j = 0; j < 2; j++) new game.Blood(pos, rot2, { speedMin: 2, speedMax: 6 });
  };

  Human.prototype.die = function() {
    console.debug('[Human] die');
    this.hp = 0;
    this.state = 'dying';
    this.alive = false;
    this.remove(this.aimLine);
    this.aimLine = null;

    // Drop weapon
    this.drop();

    // Turn off collisions
    game.Scene.current.level.remove(this);
  };

  Human.prototype.destroy = function() {
    if (!game.Scene.current) return;
    console.debug('[Human] destroy');

    game.Scene.current.remove(this);
  };

  Human.prototype.dash = function() {
    console.debug('[Human] dash');

    if (this.energy < Human.DASH_COST) return;

    this.energy -= Human.DASH_COST;
    this.state = 'dashing';
    this._dashAge = 0;

    // Speed up
    this.velocity.set(
      (-~~this.moveLeft + ~~this.moveRight) * Human.DASH_ACC,
      0,
      (-~~this.moveUp + ~~this.moveDown) * Human.DASH_ACC
    );

    // Lean
    this.main.rotation.x = -.8;

    // Create particle
    for (var i = 0; i < 6; i++) new game.Cloud(this.position);

    // Sound
    game.sound.player.dash.play();
  };

  Human.prototype.updateCollision = function() { this.collide.update() };

  Human.prototype.updatePosition = function() {
    // Movement - acceleration
    if (this.moveUp)    this.velocity.z = Math.min(-Human.ACC_MIN, this.velocity.z - Human.ACC);
    if (this.moveDown)  this.velocity.z = Math.max( Human.ACC_MIN, this.velocity.z + Human.ACC);
    if (this.moveLeft)  this.velocity.x = Math.min(-Human.ACC_MIN, this.velocity.x - Human.ACC);
    if (this.moveRight) this.velocity.x = Math.max( Human.ACC_MIN, this.velocity.x + Human.ACC);

    // Movement - drag
    if (!this.moveLeft && !this.moveRight) this.velocity.x *= Human.DRAG;
    if (!this.moveUp && !this.moveDown) this.velocity.z *= Human.DRAG;
    if (this.velocity.x && Math.abs(this.velocity.x) < Human.ACC) this.velocity.x = 0;
    if (this.velocity.z && Math.abs(this.velocity.z) < Human.ACC) this.velocity.z = 0;

    // Movement - dash
    if (this.state === 'dashing') {
      this._dashAge += game.time.delta * game.time.slomo;

      this.state = (this._dashAge < Human.DASH_DURATION) ? 'dashing' : 'moving';
    } else {
      // Movement - max speed
      if (Math.abs(this.velocity.x) > Human.MS) this.velocity.x = this.velocity.x > 0 ? Human.MS : -Human.MS;
      if (Math.abs(this.velocity.z) > Human.MS) this.velocity.z = this.velocity.z > 0 ? Human.MS : -Human.MS;

      // State
      this.state = (!this.velocity.z && !this.velocity.x) ? 'idle' : 'moving';
    }

    // Check collision
    if (this.collide.left  && this.velocity.x < 0) { this.velocity.x = 0; this.position.x+=2; }
    if (this.collide.right && this.velocity.x > 0) { this.velocity.x = 0; this.position.x-=2; }
    if (this.collide.up    && this.velocity.z < 0) { this.velocity.z = 0; this.position.z+=2; }
    if (this.collide.down  && this.velocity.z > 0) { this.velocity.z = 0; this.position.z-=2; }

    this.velocity.y = 0;
    this.velocity._x = this.velocity.x;
    this.velocity._y = this.velocity.y;

    // Slomo
    this._velocity.x = this.velocity.x * game.time.slomo;
    this._velocity.z = this.velocity.z * game.time.slomo;

    this.position.add(this._velocity);

    return this;
  };

  Human.prototype.updateRotation = function() {
    if (!this.staringAt) return;

    this._staringAt.position.x = this.staringAt.position.x;
    this._staringAt.position.z = this.staringAt.position.z;


    // Weapon fix
    if (this.weapon) {
      this._staringAt.lookAt(this.position);
      this._staringAt.translateX(this.weapon.position.x);
    }

    this._staringAt.position.y = 0;

    // Look at
    this.lookAt(this._staringAt.position);
  };

  Human.prototype.updateAnimation = function() {
    if (['idle', 'moving', 'dashing'].indexOf(this.state) !== -1){
      this.main.rotation.x *= 1 - .06 * game.time.slomo;
      this.main.rotation.z *= 1 - .06 * game.time.slomo;
      if (Math.abs(this.main.rotation.x) < .002) this.main.rotation.x = 0;
      if (Math.abs(this.main.rotation.z) < .002) this.main.rotation.z = 0;
    }

    // Dying
    if (this.state === 'dying') {
      if (this.main.rotation.x > -Math.PI * .5) {
        this.main.rotation.x -= .1;

        return;
      }

      this.state = 'dead';
      this.movable = false;
      return;
    // Moving
    } else if (this.state === 'moving' && (Math.abs(this.velocity.x) > 1 || Math.abs(this.velocity.z) > 1)) {
      if (this._animationMoveTime + 360 > game.time.elapsedInGame) return;
      this._animationMoveTime = game.time.elapsedInGame;

      this.main.rotation.z = THREE.Math.randFloat(.08, .12) * (this._animationMoveLean *= -1);
    }
  };

  Human.prototype.updateFollow = function() {
    if (!this.following) return;

    this.es.update();
  };

  Human.prototype.update = function() {
    this.updateAnimation();

    if (this.weapon) this.weapon.update();

    if (!this.movable) return;
    this.updateCollision();

    if (!this.alive) return;
    this.updatePosition();
    this.updateRotation();
    this.updateFollow();
  };

  // Static stuff
  Human.DRAG = .9; // Drag (it's multiHuman)
  Human.MS = 4; // Move Speed
  Human.ACC = .02; // Acceleration
  Human.ACC_MIN = 1.6;
  Human.COLLISION_RANGE = 16;
  Human.HP = 100;
  Human.SIGHT_DISTANCE = 400;
  Human.SIGHT_RADIUS = Math.PI * .2;
  Human.FOLLOW_DISTANCE = 128;
  Human.DASH_ACC = 8;
  Human.DASH_DURATION = 320;
  Human.DASH_COST = 24;
  Human.AIMLINE_OFFSET_Y = 64;

  Human.material = {
    aimLine: new THREE.LineBasicMaterial({ color: game.COLORS[1], depthWrite: false,  transparent: true, opacity: .4 }),
    human: new THREE.MeshPhongMaterial({ depthWrite: false, transparent: true, opacity: 0 })
  };
  Human.geometry = {
    human: new THREE.BoxGeometry(24, 48, 24),
    sight: new THREE.Geometry(),
    aimLine: new THREE.Geometry()
  };
  Human.geometry.sight.vertices.push(
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(Human.SIGHT_DISTANCE * Human.SIGHT_RADIUS, 0, Human.SIGHT_DISTANCE),
    new THREE.Vector3(-Human.SIGHT_DISTANCE * Human.SIGHT_RADIUS, 0, Human.SIGHT_DISTANCE)
  );
  Human.geometry.sight.faces.push(new THREE.Face3(0, 2, 1));
  Human.geometry.sight.computeFaceNormals();
  Human.geometry.aimLine.vertices.push(
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0, 0, 1000)
  );

  game.Human = Human;
}(game));